/*Instructors site - http://getify.me
LABjs - a dynamic script loader he wrote
grips - a templating engine
asynquence - flow control library for promises, controllers etc.
He is the head of curriculum of MakerSquare : Developer Engineered Training School (SFO,LA,Austin)
Author of youdontknowjs.com a 1100 page free book. 

This course-
1)pure functions
2)composition
3)immutability
4)closure
5)recursion
6)list transformation (map)
7)list exclusiuon (filter)
8)list composition (reduce)
9)list iteration (forEach)
*/

/*Side Effects of a function: If a function does not just return one value, but also changes some global vars or the state
of the program , then it has side effects, and this function is not a 'pure' function.
 A pure function is a function that has no side-effects. It operates entirely on it's own variables, it's own state, 
 or any of the things passed into it. So, the arguments that are passed in and any of it's own, it operates entirely 
 on that and does not change anything. A pure function does not mean it doesn't access outside state, it means 
 it doesn't change the outside state */
function bar (x,y){   //a pure function
	var z;
	foo(x);
	return [y,z];

	function foo(x){
		y++;
		z = x * y;
	}
}
bar(5,20) // [21,105]
bar(5,20) // [21,105] no side-effects.. same results. 
//the impure version is this - 
function foo (x){
	y++;
	z = x * y;
}
var y = 5, z;
foo(20);
z;   //this gives 120
foo(20);
z;   //now this gives 140 . Each time foo() is called it gives inconsitent results..

//composition: taking the output of one function and sending it as the input to the next function
function sum (x,y){
	return x + y;
}
function mult (x,y){
	return x * y;
}
function compose2 (fn1, fn2){
	return function comp(){
		var args = [].slice.call(arguments);
		return fn2(
			fn1(args.shift(),args.shift()),args.shift()
		);
	}
}
var multAndSum = compose2(mult, sum);
multAndSum(3,4,5);  // 3*4 + 5

//immutability: the const keyword gives you an immutable reference or binding not an immutable value 
var x = 2;  x++ // allowed

const y = 6; y++ //not allowed , because y points to a number 6, you can't now point it to 7

const z = [5,6,7];
z = 6; //not allowed, z points to an array object, you can't point it to 6 now
z[0] = 10; //allowed, z still points to the same array object.

const w = Object.freeze([4,5,6]);  //a built in function that sets constant for each element in the array. At the top level
w = 10; //not allowed, const makes sure w is pointing to this array
w[0] = 10; //not allowed, freeze make sure 4,5,6 are always inside this array. 
//this freeze function does not work for an array within array. The inner most array can be mutable as long it is part of
//the outer array

//an example of an impure function: It is changing the array that is outside its environment. 
//arrays, functions, objects are assigned by reference and passed by reference always (F-BONUS)
//null, undefined, string, boolean, number are assigned by value and passed by value always (a copy is passed)
function doubleThem(list){
	for(var i = 0; i < list.length; i++){
		list[i] = list[i] * 2;
	}
}
var arr = [3,4,5];
doubleThem(arr);  //[6,8,10]
//How to make it a pure function? Here - 
function doubleThem(list){
	var newList = []
	for(var i = 0; i < list.length; i++){
		newList[i] = list[i] * 2;
	}
	return newList;
}
var arr = [3,4,5];
var arr2 = doubleThem(arr);  //[6,8,10], arr is untouched

/* closure: closure is when a function remembers the variables around it even when that function is executed elsewhere
That is when you pass a function somewhere deep, it still has access to its original vars. 
Basically, you wrap a state into a function, and pass that function around, later on when the function executes, 
you access that state again in full*/
function foo(){
	var count = 0;
	return function(){
		return count++;
	};
}
var x = foo();
//after the above line is executed, foo() and count are not done and garbage collected, because there is a closure there...
x();  //0
x();  //1
x();  //2 
//but this is not the functional programming way of doing it. Each time i call x() i will get a different result!
//An example of a "pure" closure function
function sumX(x){
	return function(y){
		return x + y;
	}
}
var add10 = sumX(10);
add10(13);  //23
add10(20);  //33

/* closure question: define a function foo so that it produces a function which remembers only the first two arguments
that were passed to foo and always adds them together */
function foo(){
	var a1 = arguments[0];
	var a2 = arguments[1];
	return function goo(){
		returns a1 + a2;
	};
}
var x = foo(3,4);
x();  //7
x();  //7
x(10);  //7

/* recursion: a function that keeps calling itself until a condition is met (base case is reached)
Remember: you don't have unlimited memory and unlimited cpu
When one function calls another function, it allocates a new stack frame for it and once execution is done, parent
function deletes the stack frame. IE used to allow a total of only 13 stack frames... (i.e stack trace including libs
can't be more than 13 functions deep). With recursion call stack can get huge quick! therefore people don't use it much.
In some languages, compilers convert the recursive func into a huge iterative loop and then run it.. */

/*JS has a concept: Proper Tail Call : If the last line in func A is "return funcB()", then JS will not create a new
stack frame for funcB but actually remove funcA's stackframe and use it for funcB. In this way if my recursive func
uses only Proper Tail Calls, then in theory JS will use only 1 stack frame for it's entire execution - constant space
O(1). Thus recusion can now be used in practice if you use PTC. PTCO is PTCoptimization*/

//turn mult() into a recursive function that takes any number of arguments
function mult(x,y,z){
	return x * Y * z ;
}
//answer
function mult(...args) {
	if(args.length <= 2){
		return args[0] * args[1];
	}
    return args[0] * mult(args.slice(1));  //remove the first value and pass it // this is not a PTC!!!!!
}
mult(10,3,4,5,5); //mor ethan 15 arguments in ie8 will break the browser


//list transformation: Each element in the list is tranformed depending on a given function
function doubleIt(v) { return v * 2;}
function tripleIt (v){ return v * 3;}
function transform(arr,theFunc){
	var arr2 = [];
	for(i = 0; i < arr.length; i++){
		arr2[i] = theFunc(arr[i]);
	}
	return arr2;
}
transform([2,3,4],doubleIt);  //[4,6,8]
transform([2,3,4],tripleIt);  //[6,9,12]
//JS has a built in function called MAP.. 
[1,2,3].map(doubleIt);  //map returns a whole new array

//or just do
Array.prototype.newMap = function transform(theFunc){ same code as above, just change arr to 'this' }


//list exclusion: remove some elements from the list
function isOdd(v){ return v % 2 == 1;}  //always return TRUE if you want to keep it. 
function isItTen(v){ return v === 10;}
function exclude(arr,theFunc){
	var arr2 = [];
	for(i = 0; i < arr.length; i++){
		if(theFunc(arr[i])){
			arr2.push(arr[i]);
		}
	}
	return arr2;
}
exclude([2,3,4,5,6],isOdd);  //[3,5]
exclude([9,10,11,12],isItTen);  // [10]
//JS has a built in function called FILTER
[2,3,4,5,6].filter(isOdd);

//list composition: reduce the whole list to one value
function mult(x,y){ return x * y;}
function compose(arr,theFunc,intial){
	var accumulator = initial;
	for(i = 0; i < arr.length; i++){
		accumulator = theFunc(accumulator, a[i]);
	}
	return accumulator;
}
compose([10,20,30],mult,1); //1 has to be the initial for the mult function


//list iteration: forEach - functional programmers will never use it! Because it could have side effects
function consoleLog(v){ console.log(v); }
function iterate(arr,theFunc){
	for (i = 0; i < arr.length; i++){
		theFunc(arr[i]);
	}
}
iterate([10,20,30],consoleLog); //this won't work if consoleLog is changing the array elements too...
//JS has forEach for this
[10,20,30].forEach(consoleLog);


/*question #1:
Write two functions, each which return a different number when called */
function a(){
	return 5;
}
function b(){
	return 10;
}

/*question #2 :
 Write an add() function that takes two numbers and adds them and returns the result. Call add() with the 
results of your two functions from question#1 and print the result to the console. */
function add(x,y){
	return x + y;
}
console.log(add(a(),b()));

/*question #3 :
Write an add2() function that takes two functions instead of two numbers, and it calls those two functions
and then sends those values to add() just like you did in question#2 above */
function add2(fn1,fn2){
	return add(fn1(),fn2());
}

/*question #4 :
Replace your two functions from (1) with a single function that takes a value and returns a function back, 
where the returned function will return the value when it's called.
*/
function single(x){
	return function(){
		return x;
	};
}

/*question #5 :
Write an `addn(..)` that can take an array of 2 or more functions, and using only `add2(..)`, adds them 
together. Try it with a loop. Try it without a loop (recursion). Try it with built-in array functional 
helpers (map/reduce).*/
function addn(...args){  //LOOP
	var total = 0;
	for(i = 0; i < args.length; i++){
	  total = add2(function(){return total;}, args[i]);
	}
	return total;
}
function addn (...args){ //RECURSION
	if(args.length == 2){
		return add2(args[0],args[1]);
	}
	return args[0]() + addn(...args.slice(1)); //removes the first element. SPREAD the array and send it, don't send just array[].
}
function addn(...args){ //REDUCE
	return args.slice(1)       //remove the first element and send it as the initial value in the reduce func! Brilliant!!
	.reduce(function(acc,current){
		return function(){   //this will the acc for the next round...
			return add2(acc, current);
		}
	},args[0])(); // VVIP you need to call the func
}

//You can also do 
return args.reduce(func, foo(0))(); //let zero be the intial value

/*question #6 :
Start with an array of odd and even numbers (with some duplicates), and trim it down to only have 
unique values.*/
//??

/*question #7 :
Filter your array to only have even numbers in it.*/
arr.filter(function(x){ x % 2 === 0; });

/*question #8 :
Map your values to functions, using (4), and pass the new list of functions to the `addn(..)` 
from (5).*/
addn(arr.map(single));

/*Bonus: write tests for your functions.*/